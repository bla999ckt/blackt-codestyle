const vscode = require('vscode');
const { exec } = require('child_process');
const fs = require('fs');
const path = require('path');

// This method is called when your extension is activated
function activate(context) {
    console.log('Your extension "blackt-codestyle" is now active!');

    // Register the command to apply code style from terminal
    const disposableTerminal = vscode.commands.registerCommand('codestyle', function () {
        const editor = vscode.window.activeTextEditor;

        if (editor && editor.document) {
            const filePath = editor.document.uri.fsPath;
            if (fs.existsSync(filePath)) {
                runStyle50(context, filePath); // Run the style50 command on the file
            } else {
                vscode.window.showErrorMessage(`File not found: ${filePath}`);
            }
        } else {
            vscode.window.showErrorMessage('No active editor or document found.');
        }
    });

    // Register the command to apply code style via the command palette
    const disposablePanel = vscode.commands.registerCommand('blackt-codestyle.applyCodeStyle', function () {
        const editor = vscode.window.activeTextEditor;

        if (editor && editor.document) {
            const filePath = editor.document.uri.fsPath;
            runStyle50(context, filePath); // Run the style50 command on the active file
        } else {
            vscode.window.showErrorMessage('No active editor or document found.');
        }
    });

    // Listen for file changes and recheck the code
    vscode.workspace.onDidSaveTextDocument((document) => {
        if (document.languageId !== 'plaintext') {
            runStyle50(context, document.uri.fsPath); // Re-run style50 if the file is not a read-only output file
        }
    });

    context.subscriptions.push(disposableTerminal, disposablePanel);
}

// Function to invoke the style50 command on the file
function runStyle50(context, filePath) {
    exec(`which style50`, (error, stdout, stderr) => {
        if (error) {
            vscode.window.showErrorMessage(`Error: style50 not found. Ensure it is installed and available in your PATH.`);
            return;
        }

        // Run the style50 command on the file
        exec(`style50 "${filePath}"`, (error, stdout, stderr) => {
            if (error) {
                vscode.window.showErrorMessage(`Error formatting file: ${stderr}`);
                return;
            }

            // Log the stdout to check if it contains the formatted content
            console.log('stdout:', stdout);

            // Check if stdout is defined and not empty
            if (!stdout) {
                vscode.window.showErrorMessage('No output from style50.');
                return;
            }

            // Check if the result is "Looks good!"
            if (stdout.includes('Looks good!')) {
                vscode.window.showInformationMessage('Your code looks good!');
                deleteAndCloseFormattedFile();
            } else {
                displayFormattedCode(context, filePath, stdout);
            }
        });
    });
}


// Function to clean the style50 output, remove unwanted parts, and escape terminal color codes
function cleanOutput(formattedContent) {
    // Remove unnecessary lines (e.g., version info and additional comments)
    const cleanedContent = formattedContent
        .replace(/Results generated by style50.*\n/g, '') // Remove version info
        .replace(/And consider adding more comments!\n/g, ''); // Remove extra comments

    // Remove terminal color codes (e.g., [0m)
    return cleanedContent.replace(/\x1b\[\d+m/g, '').trim();
}

// Function to delete and close the output file
function deleteAndCloseFormattedFile() {
    const editor = vscode.window.activeTextEditor;

    if (editor) {
        const outputFileUri = editor.document.uri;

        // Check if this is the temporary output file
        const outputFileName = path.basename(outputFileUri.fsPath);
        if (outputFileName.startsWith('codestyle')) {
            // First, close the output file from the editor
            vscode.commands.executeCommand('workbench.action.closeActiveEditor').then(() => {
                // Delete the output file once it has been closed
                fs.unlink(outputFileUri.fsPath, (err) => {
                    if (err) {
                        console.error(`Failed to delete the output file: ${err}`);
                    } else {
                        console.log(`Output file deleted: ${outputFileUri.fsPath}`);
                    }
                });
            });
        }
    }
}

// Function to display formatted code with styling
// Function to display formatted code with styling
async function displayFormattedCode(context ,filePath, formattedContent) {
    console.log('Displaying formatted code');
    
    // Log the formatted content before cleaning
    console.log('Formatted content:', formattedContent);

    // Clean up the style50 result, removing the unwanted parts and terminal color codes
    const cleanedContent = cleanOutput(formattedContent);
    console.log('Cleaned content:', cleanedContent);

    const editor = vscode.window.activeTextEditor;

    if (editor) {
        const originalDocument = editor.document;
        const fileExtension = path.extname(filePath); // Get the file extension from the original file

        // Get the output file path (same as input file, but with "codestyle" as the prefix)
        const outputFileName = `codestyle${fileExtension}`;
        const outputFilePath = path.join(path.dirname(filePath), outputFileName);

        try {
            // Write the cleaned content to a temporary output file
            fs.writeFileSync(outputFilePath, cleanedContent);

            // Open the original document in the left editor column
            const doc = await vscode.workspace.openTextDocument(filePath);
            await vscode.window.showTextDocument(doc, vscode.ViewColumn.One);

            // Open and display the temporary output file in the right editor column
            const formattedDoc = await vscode.workspace.openTextDocument(outputFilePath);
            const formattedEditor = await vscode.window.showTextDocument(formattedDoc, vscode.ViewColumn.Beside);

            // Set the language mode based on the file extension
            const languageId = getLanguageId(fileExtension);
            await vscode.languages.setTextDocumentLanguage(formattedDoc, languageId);

            // Disable editing by listening for changes and reverting them
            const disposable = vscode.workspace.onDidChangeTextDocument((e) => {
                if (e.document.uri.fsPath === outputFilePath) {
                    // Revert the document content to the original (cleaned) content
                    const textEditor = vscode.window.visibleTextEditors.find((editor) => editor.document.uri.fsPath === outputFilePath);
                    if (textEditor) {
                        const range = new vscode.Range(0, 0, e.document.lineCount, 0);
                        textEditor.edit((editBuilder) => {
                            editBuilder.replace(range, cleanedContent); // Apply the content
                        });
                    }
                }
            });

            // Store the disposable in the context so it can be cleaned up later
            context.subscriptions.push(disposable);

            // Highlighting logic (red and green based on style50 output)
            const redRanges = identifyRedRanges(cleanedContent);
            const greenRanges = identifyGreenRanges(cleanedContent);

            // Apply the highlights for red (deletions) and green (additions)
            highlightRedInEditor(formattedDoc, redRanges);
            highlightGreenInEditor(formattedDoc, greenRanges);

            // Show an information message to the user
            vscode.window.showInformationMessage(`Codestyle applied to ${filePath}`);

            // Set a timer to delete the temporary output file after 5 seconds
            setTimeout(() => {
                fs.unlink(outputFilePath, (err) => {
                    if (err) {
                        console.error(`Failed to delete the output file: ${err}`);
                    } else {
                        console.log(`Successfully deleted output file: ${outputFilePath}`);
                    }
                });
            }, 5000); // File will be deleted after 5 seconds

        } catch (err) {
            vscode.window.showErrorMessage(`Error processing files: ${err.message}`);
        }
    }
}

// Helper function to get the language ID based on the file extension
function getLanguageId(fileExtension) {
    const extensionToLanguage = {
        '.js': 'javascript',
        '.py': 'python',
        '.cpp': 'cpp',
        '.c': 'c',
        '.java': 'java',
        '.html': 'html',
        '.css': 'css',
        '.json': 'json',
        '.md': 'markdown',
    };

    return extensionToLanguage[fileExtension] || 'plaintext';
}

function highlightRedInEditor(doc, lineRanges) {
    const editor = vscode.window.visibleTextEditors.find((e) => e.document.uri.fsPath === doc.uri.fsPath);
    if (editor) {
        const decorationType = vscode.window.createTextEditorDecorationType({
            backgroundColor: 'rgba(255, 0, 0, 0.3)', // Red highlight
        });

        const ranges = lineRanges.map(line => new vscode.Range(line, 0, line + 1, 0));
        editor.setDecorations(decorationType, ranges);
    }
}

function highlightGreenInEditor(doc, lineRanges) {
    const editor = vscode.window.visibleTextEditors.find((e) => e.document.uri.fsPath === doc.uri.fsPath);
    if (editor) {
        const decorationType = vscode.window.createTextEditorDecorationType({
            backgroundColor: 'rgba(0, 255, 0, 0.3)', // Green highlight
        });

        const ranges = lineRanges.map(line => new vscode.Range(line, 0, line + 1, 0));
        editor.setDecorations(decorationType, ranges);
    }
}


// Identify ranges for red highlights (deletions) - placeholder logic, adjust accordingly
function identifyRedRanges(content) {
    // Placeholder: This should be a logic to identify which lines need deletions
    return [2, 4, 6]; // Example line numbers that should be highlighted in red
}

// Identify ranges for green highlights (additions) - placeholder logic, adjust accordingly
function identifyGreenRanges(content) {
    // Placeholder: This should be a logic to identify which lines need additions
    return [1, 3, 5]; // Example line numbers that should be highlighted in green
}

// This method is called when your extension is deactivated
function deactivate() {}

module.exports = {
    activate,
    deactivate
};
